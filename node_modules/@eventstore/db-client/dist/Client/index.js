"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Client_throwOnAppendFailure, _Client_connectionSettings, _Client_channelCredentials, _Client_insecure, _Client_keepAliveInterval, _Client_keepAliveTimeout, _Client_defaultDeadline, _Client_defaultCredentials, _Client_nextChannelSettings, _Client_channel, _Client_serverFeatures, _Client_grpcClients, _Client_http, _Client_connectionName;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const stream_1 = require("stream");
const uuid_1 = require("uuid");
const grpc_js_1 = require("@grpc/grpc-js");
const call_1 = require("@grpc/grpc-js/build/src/call");
const utils_1 = require("../utils");
const discovery_1 = require("./discovery");
const parseConnectionString_1 = require("./parseConnectionString");
const ServerFeatures_1 = require("./ServerFeatures");
const http_1 = require("./http");
class Client {
    constructor({ throwOnAppendFailure = true, keepAliveInterval = 10000, keepAliveTimeout = 10000, defaultDeadline = 10000, connectionName = (0, uuid_1.v4)(), ...connectionSettings }, channelCredentials = { insecure: false }, defaultUserCredentials) {
        _Client_throwOnAppendFailure.set(this, void 0);
        _Client_connectionSettings.set(this, void 0);
        _Client_channelCredentials.set(this, void 0);
        _Client_insecure.set(this, void 0);
        _Client_keepAliveInterval.set(this, void 0);
        _Client_keepAliveTimeout.set(this, void 0);
        _Client_defaultDeadline.set(this, void 0);
        _Client_defaultCredentials.set(this, void 0);
        _Client_nextChannelSettings.set(this, void 0);
        _Client_channel.set(this, void 0);
        _Client_serverFeatures.set(this, void 0);
        _Client_grpcClients.set(this, new Map());
        _Client_http.set(this, void 0);
        _Client_connectionName.set(this, void 0);
        // Internal access to grpc client.
        this.getGRPCClient = async (Client, debugName) => {
            if (__classPrivateFieldGet(this, _Client_grpcClients, "f").has(Client)) {
                utils_1.debug.connection("Using existing grpc client for %s", debugName);
            }
            else {
                utils_1.debug.connection("Createing client for %s", debugName);
                __classPrivateFieldGet(this, _Client_grpcClients, "f").set(Client, this.createGRPCClient(Client));
            }
            return __classPrivateFieldGet(this, _Client_grpcClients, "f").get(Client);
        };
        this.disposableStreams = new Set();
        // Internal handled execution
        this.GRPCStreamCreator = (Client, debugName, creator, cache) => async () => {
            const client = await this.getGRPCClient(Client, debugName);
            if (cache && cache.has(client))
                return cache.get(client);
            const streamPromise = creator(client);
            cache === null || cache === void 0 ? void 0 : cache.set(client, streamPromise);
            const stream = await streamPromise;
            this.disposableStreams.add(stream);
            (0, stream_1.finished)(stream, (err) => {
                cache === null || cache === void 0 ? void 0 : cache.delete(client);
                this.disposableStreams.delete(stream);
                if (err)
                    this.handleError(client, err);
            });
            return stream;
        };
        this.dispose = async () => {
            utils_1.debug.command(`Disposing ${this.disposableStreams.size} streams.`);
            const promises = [];
            for (const stream of this.disposableStreams) {
                promises.push(new Promise((resolve) => {
                    (0, stream_1.finished)(stream, resolve);
                }));
                if (stream instanceof call_1.ClientWritableStreamImpl ||
                    stream instanceof call_1.ClientDuplexStreamImpl ||
                    stream instanceof call_1.ClientUnaryCallImpl ||
                    stream instanceof call_1.ClientReadableStreamImpl) {
                    stream.cancel();
                }
                else {
                    stream.destroy();
                }
            }
            await Promise.allSettled(promises);
            utils_1.debug.command(`Disposed ${promises.length} streams.`);
        };
        // Internal handled execution
        this.execute = async (Client, debugName, action) => {
            const client = await this.getGRPCClient(Client, debugName);
            try {
                return await action(client);
            }
            catch (error) {
                this.handleError(client, error);
                throw error;
            }
        };
        this.getChannel = async () => {
            if (__classPrivateFieldGet(this, _Client_channel, "f")) {
                utils_1.debug.connection("Using existing connection");
                return __classPrivateFieldGet(this, _Client_channel, "f");
            }
            __classPrivateFieldSet(this, _Client_channel, this.createChannel(), "f");
            return __classPrivateFieldGet(this, _Client_channel, "f");
        };
        this.createGRPCClient = async (Client) => {
            const channelOverride = await this.getChannel();
            const client = new Client(null, null, {
                channelOverride,
            });
            return client;
        };
        this.shouldReconnect = (err) => {
            const error = (0, utils_1.convertToCommandError)(err);
            if (error instanceof utils_1.NotLeaderError) {
                return [true, error.leader];
            }
            return [error instanceof utils_1.UnavailableError];
        };
        this.handleError = async (client, error) => {
            const [shouldReconnect, nextEndpoint] = this.shouldReconnect(error);
            if (!shouldReconnect)
                return;
            utils_1.debug.connection("Got reconnection error", error.message);
            const failedChannel = client.getChannel();
            const currentChannel = await __classPrivateFieldGet(this, _Client_channel, "f");
            if (failedChannel !== currentChannel) {
                utils_1.debug.connection("Channel already reconnected");
                return;
            }
            utils_1.debug.connection(`Reconnection required${nextEndpoint ? ` to: ${nextEndpoint}` : ""}`);
            const [_protocol, address, port] = failedChannel.getTarget().split(":");
            failedChannel.close();
            __classPrivateFieldGet(this, _Client_grpcClients, "f").clear();
            __classPrivateFieldSet(this, _Client_channel, undefined, "f");
            __classPrivateFieldSet(this, _Client_serverFeatures, undefined, "f");
            __classPrivateFieldSet(this, _Client_nextChannelSettings, {
                failedEndpoint: {
                    address,
                    port: Number.parseInt(port),
                },
                nextEndpoint,
            }, "f");
        };
        this.createChannel = async () => {
            const uri = await this.resolveUri();
            utils_1.debug.connection(`Connecting to http${__classPrivateFieldGet(this, _Client_channelCredentials, "f")._isSecure() ? "s" : ""}://%s`, uri);
            __classPrivateFieldSet(this, _Client_nextChannelSettings, undefined, "f");
            return new grpc_js_1.Channel(uri, __classPrivateFieldGet(this, _Client_channelCredentials, "f"), {
                "grpc.keepalive_time_ms": __classPrivateFieldGet(this, _Client_keepAliveInterval, "f") < 0
                    ? Number.MAX_VALUE
                    : __classPrivateFieldGet(this, _Client_keepAliveInterval, "f"),
                "grpc.keepalive_timeout_ms": __classPrivateFieldGet(this, _Client_keepAliveTimeout, "f") < 0 ? Number.MAX_VALUE : __classPrivateFieldGet(this, _Client_keepAliveTimeout, "f"),
                // EventStore allows events of up to 16mb to be written internally.
                // While you can't write events this large through gRPC, you could do so through the TCP client, or through projections.
                // To allow the client to read any event that EventStoreDB was able to write, we want to hardcode the max receive message length to 17mb.
                "grpc.max_receive_message_length": 17 * 1024 * 1024,
            });
        };
        this.resolveUri = async () => {
            var _a, _b;
            if ((_a = __classPrivateFieldGet(this, _Client_nextChannelSettings, "f")) === null || _a === void 0 ? void 0 : _a.nextEndpoint) {
                const { address, port } = __classPrivateFieldGet(this, _Client_nextChannelSettings, "f").nextEndpoint;
                return `${address}:${port}`;
            }
            if ("endpoint" in __classPrivateFieldGet(this, _Client_connectionSettings, "f")) {
                const { endpoint } = __classPrivateFieldGet(this, _Client_connectionSettings, "f");
                return typeof endpoint === "string"
                    ? endpoint
                    : `${endpoint.address}:${endpoint.port}`;
            }
            try {
                const { address, port } = await (0, discovery_1.discoverEndpoint)(__classPrivateFieldGet(this, _Client_connectionSettings, "f"), __classPrivateFieldGet(this, _Client_channelCredentials, "f"), (_b = __classPrivateFieldGet(this, _Client_nextChannelSettings, "f")) === null || _b === void 0 ? void 0 : _b.failedEndpoint);
                return `${address}:${port}`;
            }
            catch (error) {
                __classPrivateFieldGet(this, _Client_grpcClients, "f").clear();
                __classPrivateFieldSet(this, _Client_channel, undefined, "f");
                throw error;
            }
        };
        this.createCredentialsMetadataGenerator = ({ username, password, }) => (_, cb) => {
            const metadata = new grpc_js_1.Metadata();
            if (__classPrivateFieldGet(this, _Client_insecure, "f")) {
                utils_1.debug.connection("Credentials are unsupported in insecure mode, and will be ignored.");
            }
            else {
                const auth = Buffer.from(`${username}:${password}`).toString("base64");
                metadata.add("authorization", `Basic ${auth}`);
            }
            return cb(null, metadata);
        };
        this.callArguments = ({ credentials = __classPrivateFieldGet(this, _Client_defaultCredentials, "f"), requiresLeader, deadline, }, callOptions) => {
            var _a;
            const metadata = new grpc_js_1.Metadata();
            const options = callOptions ? { ...callOptions } : {};
            metadata.add("connection-name", __classPrivateFieldGet(this, _Client_connectionName, "f"));
            if (requiresLeader) {
                metadata.add("requires-leader", "true");
            }
            if (credentials) {
                options.credentials = grpc_js_1.CallCredentials.createFromMetadataGenerator(this.createCredentialsMetadataGenerator(credentials));
            }
            options.deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : this.createDeadline(deadline);
            return [metadata, options];
        };
        this.supports = async (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        method, feature) => (await this.capabilities).supports(method, feature);
        if (keepAliveInterval < -1) {
            throw new Error(`Invalid keepAliveInterval "${keepAliveInterval}". Please provide a positive integer, or -1 to disable.`);
        }
        if (keepAliveTimeout < -1) {
            throw new Error(`Invalid keepAliveTimeout "${keepAliveTimeout}". Please provide a positive integer, or -1 to disable.`);
        }
        if (keepAliveInterval > -1 && keepAliveInterval < 10000) {
            console.warn(`Specified KeepAliveInterval of ${keepAliveInterval} is less than recommended 10_000 ms.`);
        }
        if (defaultDeadline <= 0) {
            throw new Error(`Invalid defaultDeadline "${defaultDeadline}". Please provide a positive integer.`);
        }
        __classPrivateFieldSet(this, _Client_throwOnAppendFailure, throwOnAppendFailure, "f");
        __classPrivateFieldSet(this, _Client_keepAliveInterval, keepAliveInterval, "f");
        __classPrivateFieldSet(this, _Client_keepAliveTimeout, keepAliveTimeout, "f");
        __classPrivateFieldSet(this, _Client_defaultDeadline, defaultDeadline, "f");
        __classPrivateFieldSet(this, _Client_connectionSettings, connectionSettings, "f");
        __classPrivateFieldSet(this, _Client_insecure, !!channelCredentials.insecure, "f");
        __classPrivateFieldSet(this, _Client_defaultCredentials, defaultUserCredentials, "f");
        __classPrivateFieldSet(this, _Client_connectionName, connectionName, "f");
        __classPrivateFieldSet(this, _Client_http, new http_1.HTTP(this, channelCredentials, defaultUserCredentials), "f");
        if (__classPrivateFieldGet(this, _Client_insecure, "f")) {
            utils_1.debug.connection("Using insecure channel");
            __classPrivateFieldSet(this, _Client_channelCredentials, grpc_js_1.credentials.createInsecure(), "f");
        }
        else {
            utils_1.debug.connection("Using secure channel with credentials %O", channelCredentials);
            __classPrivateFieldSet(this, _Client_channelCredentials, grpc_js_1.credentials.createSsl(channelCredentials.rootCertificate, channelCredentials.privateKey, channelCredentials.certChain, channelCredentials.verifyOptions), "f");
        }
    }
    // eslint-disable-next-line jsdoc/require-param
    /**
     * Returns a connection from a connection string.
     * @param connectionString The connection string for your database.
     */
    static connectionString(connectionString, ...parts) {
        const string = Array.isArray(connectionString)
            ? connectionString.reduce((acc, chunk, i) => { var _a; return `${acc}${chunk}${(_a = parts[i]) !== null && _a !== void 0 ? _a : ""}`; }, "")
            : connectionString;
        utils_1.debug.connection(`Using connection string: ${string}`);
        const options = (0, parseConnectionString_1.parseConnectionString)(string);
        const channelCredentials = {
            insecure: options.tls === false,
        };
        if (options.tlsCAFile) {
            if (channelCredentials.insecure) {
                utils_1.debug.connection("tslCAFile passed to insecure connection. Will be ignored.");
            }
            else {
                const resolvedPath = (0, path_1.isAbsolute)(options.tlsCAFile)
                    ? options.tlsCAFile
                    : (0, path_1.resolve)(process.cwd(), options.tlsCAFile);
                utils_1.debug.connection(`Resolved tslCAFile option as ${resolvedPath}`);
                if (!(0, fs_1.existsSync)(resolvedPath)) {
                    throw new Error("Failed to load certificate file. File was not found.");
                }
                channelCredentials.rootCertificate = (0, fs_1.readFileSync)(resolvedPath);
            }
        }
        if (options.dnsDiscover) {
            const [discover] = options.hosts;
            if (options.hosts.length > 1) {
                utils_1.debug.connection(`More than one address provided for discovery. Using first: ${discover.address}:${discover.port}.`);
            }
            return new Client({
                discover,
                nodePreference: options.nodePreference,
                discoveryInterval: options.discoveryInterval,
                gossipTimeout: options.gossipTimeout,
                maxDiscoverAttempts: options.maxDiscoverAttempts,
                throwOnAppendFailure: options.throwOnAppendFailure,
                keepAliveInterval: options.keepAliveInterval,
                keepAliveTimeout: options.keepAliveTimeout,
                defaultDeadline: options.defaultDeadline,
                connectionName: options.connectionName,
            }, channelCredentials, options.defaultCredentials);
        }
        if (options.hosts.length > 1) {
            return new Client({
                endpoints: options.hosts,
                nodePreference: options.nodePreference,
                discoveryInterval: options.discoveryInterval,
                gossipTimeout: options.gossipTimeout,
                maxDiscoverAttempts: options.maxDiscoverAttempts,
                throwOnAppendFailure: options.throwOnAppendFailure,
                keepAliveInterval: options.keepAliveInterval,
                keepAliveTimeout: options.keepAliveTimeout,
                defaultDeadline: options.defaultDeadline,
                connectionName: options.connectionName,
            }, channelCredentials, options.defaultCredentials);
        }
        return new Client({
            endpoint: options.hosts[0],
            throwOnAppendFailure: options.throwOnAppendFailure,
            keepAliveInterval: options.keepAliveInterval,
            keepAliveTimeout: options.keepAliveTimeout,
            defaultDeadline: options.defaultDeadline,
            connectionName: options.connectionName,
        }, channelCredentials, options.defaultCredentials);
    }
    /**
     * The name of the connection to use in logs.
     * Can be set via {@link ClientOptions.connectionName} or `connectionName` in the connection string.
     */
    get connectionName() {
        return __classPrivateFieldGet(this, _Client_connectionName, "f");
    }
    get HTTPRequest() {
        return __classPrivateFieldGet(this, _Client_http, "f").request;
    }
    createDeadline(deadline = __classPrivateFieldGet(this, _Client_defaultDeadline, "f")) {
        return new Date(Date.now() + deadline);
    }
    get capabilities() {
        if (!__classPrivateFieldGet(this, _Client_serverFeatures, "f")) {
            utils_1.debug.command("Fetching server capabilities");
            __classPrivateFieldSet(this, _Client_serverFeatures, this.execute(...ServerFeatures_1.ServerFeatures.createServerFeatures), "f");
        }
        return __classPrivateFieldGet(this, _Client_serverFeatures, "f");
    }
    get throwOnAppendFailure() {
        return __classPrivateFieldGet(this, _Client_throwOnAppendFailure, "f");
    }
}
exports.Client = Client;
_Client_throwOnAppendFailure = new WeakMap(), _Client_connectionSettings = new WeakMap(), _Client_channelCredentials = new WeakMap(), _Client_insecure = new WeakMap(), _Client_keepAliveInterval = new WeakMap(), _Client_keepAliveTimeout = new WeakMap(), _Client_defaultDeadline = new WeakMap(), _Client_defaultCredentials = new WeakMap(), _Client_nextChannelSettings = new WeakMap(), _Client_channel = new WeakMap(), _Client_serverFeatures = new WeakMap(), _Client_grpcClients = new WeakMap(), _Client_http = new WeakMap(), _Client_connectionName = new WeakMap();
