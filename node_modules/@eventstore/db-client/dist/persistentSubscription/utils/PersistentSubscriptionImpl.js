"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PersistentSubscriptionImpl_grpcStream, _PersistentSubscriptionImpl_convertGrpcEvent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistentSubscriptionImpl = void 0;
const stream_1 = require("stream");
const grpc_js_1 = require("@grpc/grpc-js");
const persistent_pb_1 = require("../../../generated/persistent_pb");
const utils_1 = require("../../utils");
class PersistentSubscriptionImpl extends stream_1.Transform {
    constructor(createGRPCStream, convertGrpcEvent, options) {
        super({ ...options, objectMode: true });
        _PersistentSubscriptionImpl_grpcStream.set(this, void 0);
        _PersistentSubscriptionImpl_convertGrpcEvent.set(this, void 0);
        this.initialize = async () => {
            try {
                (await __classPrivateFieldGet(this, _PersistentSubscriptionImpl_grpcStream, "f"))
                    .on("error", (err) => {
                    if (err.code === grpc_js_1.status.CANCELLED)
                        return;
                    const error = (0, utils_1.convertToCommandError)(err);
                    this.emit("error", error);
                })
                    .pipe(this);
            }
            catch (error) {
                this.emit("error", error);
            }
        };
        __classPrivateFieldSet(this, _PersistentSubscriptionImpl_grpcStream, createGRPCStream(), "f");
        __classPrivateFieldSet(this, _PersistentSubscriptionImpl_convertGrpcEvent, convertGrpcEvent, "f");
        this.initialize();
    }
    _transform(resp, _encoding, next) {
        if (resp.hasSubscriptionConfirmation()) {
            this.emit("confirmation");
        }
        if (resp.hasEvent()) {
            const resolved = __classPrivateFieldGet(this, _PersistentSubscriptionImpl_convertGrpcEvent, "f").call(this, resp.getEvent());
            next(null, resolved);
            return;
        }
        next();
    }
    async ack(...events) {
        var _a, _b, _c;
        try {
            const req = new persistent_pb_1.ReadReq();
            const ack = new persistent_pb_1.ReadReq.Ack();
            for (const event of events) {
                const id = (_b = (_a = event.link) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = event.event) === null || _c === void 0 ? void 0 : _c.id;
                // A resolved event will always have either link or event (or both), so this should to be unreachable
                if (!id)
                    throw new Error("Attempted to ack an event with no id");
                const uuid = (0, utils_1.createUUID)(id);
                ack.addIds(uuid);
            }
            req.setAck(ack);
            const stream = await __classPrivateFieldGet(this, _PersistentSubscriptionImpl_grpcStream, "f");
            await (0, utils_1.backpressuredWrite)(stream, req);
        }
        catch (error) {
            throw (0, utils_1.convertToCommandError)(error);
        }
    }
    async nack(action, reason, ...events) {
        var _a, _b, _c;
        try {
            const req = new persistent_pb_1.ReadReq();
            const nack = new persistent_pb_1.ReadReq.Nack();
            switch (action) {
                case "park":
                    nack.setAction(persistent_pb_1.ReadReq.Nack.Action.PARK);
                    break;
                case "retry":
                    nack.setAction(persistent_pb_1.ReadReq.Nack.Action.RETRY);
                    break;
                case "skip":
                    nack.setAction(persistent_pb_1.ReadReq.Nack.Action.SKIP);
                    break;
                case "stop":
                    nack.setAction(persistent_pb_1.ReadReq.Nack.Action.STOP);
                    break;
            }
            for (const event of events) {
                const id = (_b = (_a = event.link) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = event.event) === null || _c === void 0 ? void 0 : _c.id;
                // A resolved event will always have either link or event (or both), so this should to be unreachable
                if (!id)
                    throw new Error("Attempted to ack an event with no id");
                const uuid = (0, utils_1.createUUID)(id);
                nack.addIds(uuid);
            }
            nack.setReason(reason);
            req.setNack(nack);
            const stream = await __classPrivateFieldGet(this, _PersistentSubscriptionImpl_grpcStream, "f");
            await (0, utils_1.backpressuredWrite)(stream, req);
        }
        catch (error) {
            throw (0, utils_1.convertToCommandError)(error);
        }
    }
    async unsubscribe() {
        const stream = await __classPrivateFieldGet(this, _PersistentSubscriptionImpl_grpcStream, "f");
        return new Promise((resolve) => {
            // https://github.com/grpc/grpc-node/issues/1464
            // https://github.com/grpc/grpc-node/issues/1652
            setImmediate(() => {
                stream.cancel();
                resolve();
            });
        });
    }
}
exports.PersistentSubscriptionImpl = PersistentSubscriptionImpl;
_PersistentSubscriptionImpl_grpcStream = new WeakMap(), _PersistentSubscriptionImpl_convertGrpcEvent = new WeakMap();
