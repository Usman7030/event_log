"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.append = void 0;
const streams_pb_1 = require("../../../generated/streams_pb");
const shared_pb_1 = require("../../../generated/shared_pb");
const streams_grpc_pb_1 = require("../../../generated/streams_grpc_pb");
const utils_1 = require("../../utils");
const append = async function (streamName, events, { expectedRevision, ...baseOptions }) {
    const header = new streams_pb_1.AppendReq();
    const options = new streams_pb_1.AppendReq.Options();
    const identifier = (0, utils_1.createStreamIdentifier)(streamName);
    options.setStreamIdentifier(identifier);
    switch (expectedRevision) {
        case "any": {
            options.setAny(new shared_pb_1.Empty());
            break;
        }
        case "no_stream": {
            options.setNoStream(new shared_pb_1.Empty());
            break;
        }
        case "stream_exists": {
            options.setStreamExists(new shared_pb_1.Empty());
            break;
        }
        default: {
            options.setRevision(expectedRevision.toString(10));
            break;
        }
    }
    header.setOptions(options);
    utils_1.debug.command("appendToStream: %O", {
        streamName,
        events,
        options: { expectedRevision, ...baseOptions },
    });
    utils_1.debug.command_grpc("appendToStream: %g", header);
    return this.execute(streams_grpc_pb_1.StreamsClient, "appendToStream", (client) => new Promise(async (resolve, reject) => {
        const sink = client.append(...this.callArguments(baseOptions), (error, resp) => {
            if (error != null) {
                return reject((0, utils_1.convertToCommandError)(error));
            }
            if (resp.hasWrongExpectedVersion()) {
                const grpcError = resp.getWrongExpectedVersion();
                let expected = "any";
                switch (true) {
                    case grpcError.hasExpectedRevision(): {
                        expected = BigInt(grpcError.getExpectedRevision());
                        break;
                    }
                    case grpcError.hasExpectedStreamExists(): {
                        expected = "stream_exists";
                        break;
                    }
                    case grpcError.hasExpectedNoStream(): {
                        expected = "no_stream";
                        break;
                    }
                }
                if (this.throwOnAppendFailure) {
                    return reject(new utils_1.WrongExpectedVersionError(null, {
                        streamName: streamName,
                        current: grpcError.hasCurrentRevision()
                            ? BigInt(grpcError.getCurrentRevision())
                            : "no_stream",
                        expected,
                    }));
                }
                const nextExpectedRevision = grpcError.hasCurrentRevision()
                    ? BigInt(grpcError.getCurrentRevision())
                    : BigInt(-1);
                return resolve({
                    success: false,
                    nextExpectedRevision,
                    position: undefined,
                });
            }
            if (resp.hasSuccess()) {
                const success = resp.getSuccess();
                const nextExpectedRevision = BigInt(success.getCurrentRevision());
                const grpcPosition = success.getPosition();
                const position = grpcPosition
                    ? {
                        commit: BigInt(grpcPosition.getCommitPosition()),
                        prepare: BigInt(grpcPosition.getPreparePosition()),
                    }
                    : undefined;
                return resolve({
                    success: true,
                    nextExpectedRevision,
                    position,
                });
            }
        });
        sink.on("error", (err) => reject(err));
        await (0, utils_1.backpressuredWrite)(sink, header);
        for (const event of events) {
            const entry = new streams_pb_1.AppendReq();
            const message = new streams_pb_1.AppendReq.ProposedMessage();
            const id = (0, utils_1.createUUID)(event.id);
            message.setId(id);
            message.getMetadataMap().set("type", event.type);
            message.getMetadataMap().set("content-type", event.contentType);
            switch (event.contentType) {
                case "application/json": {
                    const data = JSON.stringify(event.data);
                    message.setData(Buffer.from(data, "utf8").toString("base64"));
                    break;
                }
                case "application/octet-stream": {
                    message.setData(event.data);
                    break;
                }
            }
            if (event.metadata) {
                if (event.metadata.constructor === Uint8Array) {
                    message.setCustomMetadata(event.metadata);
                }
                else {
                    const metadata = JSON.stringify(event.metadata);
                    message.setCustomMetadata(Buffer.from(metadata, "utf8").toString("base64"));
                }
            }
            entry.setProposedMessage(message);
            await (0, utils_1.backpressuredWrite)(sink, entry);
        }
        sink.end();
    }));
};
exports.append = append;
